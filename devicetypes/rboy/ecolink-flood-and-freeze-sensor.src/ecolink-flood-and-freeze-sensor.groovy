/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "01.00.04"
}

/*
 * Ecolink Flood and Freeze Sensor
 *
 * Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
 * Change log:
 * 2020-02-05 - (v01.00.04) Added health check capability
 * 2020-01-20 - (v01.00.03) Fix for broken ST Android Classic app 2.18
 * 2018-08-02 - (v01.00.02) Added basic support for new ST app
 * 2018-05-17 - (v01.00.01) Dont' reset temperature and freeze values after updating the device settings if already initialized
 * 2017-12-05 - (v01.00.00) Initial release
 *
 *  Copyright 2014 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 */

preferences {
    input title: "", description: "Ecolink Flood and Freeze Sensor Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph"
}

metadata {
	definition (name: "Ecolink Flood and Freeze Sensor", namespace: "rboy", author: "RBoy Apps", ocfDeviceType: "x.com.st.d.sensor.moisture", mnmn: "SmartThings", vid:"generic-leak") {
		capability "Water Sensor"
		capability "Sensor"
		capability "Battery"
        capability "Temperature Measurement"
        capability "Tamper Alert"
        capability "Health Check"
        
        attribute "codeVersion", "string"
        attribute "dhName", "string"

		fingerprint deviceId: '0x0701', inClusters: '0x5E,0x86,0x72,0x5A,0x73,0x80,0x30,0x71,0x85,0x59,0x84', manufacturer: "Ecolink", model: "Flood and Freeze Sensor"

        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"0701", mfr:"014A", prod:"0005", model:"0010", cc:"5E,86,72,5A,73,80,30,71,85,59,84", deviceJoinName:"Ecolink Flood and Freeze Sensor"
        fingerprint type:"0701", mfr:"014A", prod:"0005", model:"000F", cc:"5E,86,72,5A,73,80,30,71,85,59,84", deviceJoinName:"Ecolink Flood and Freeze Sensor (OEM)"
	}

	tiles(scale:2) {
		multiAttributeTile(name:"water", type: "generic", width: 6, height: 4){
			tileAttribute("device.water", key: "PRIMARY_CONTROL") {
				attributeState("dry", label: 'Dry',, icon:"st.alarm.water.dry", backgroundColor:"#ffffff")
				attributeState("wet", label: 'Wet',, icon:"st.alarm.water.wet", backgroundColor:"#00A0DC")
			}
		}
		standardTile("temperatureState", "device.temperature", width: 2, height: 2) {
			state "23", label: 'Normal', icon:"st.alarm.temperature.normal", backgroundColor:"#ffffff", defaultState: true
			state "74", label: 'Normal', icon:"st.alarm.temperature.normal", backgroundColor:"#ffffff"
			state "0", label: 'Freezing', icon:"st.alarm.temperature.freeze", backgroundColor:"#00A0DC"
			state "32", label: 'Freezing', icon:"st.alarm.temperature.freeze", backgroundColor:"#00A0DC"
		}
		valueTile("battery", "device.battery", width: 2, height: 2, inactiveLabel: false) {
            state "battery", label:'${currentValue}%', unit: "", icon: "https://www.rboyapps.com/images/battery.png",
                backgroundColors:[
                    [value: 15, color: "#ff0000"],
                    [value: 30, color: "#fd4e3a"],
                    [value: 50, color: "#fda63a"],
                    [value: 60, color: "#fdeb3a"],
                    [value: 75, color: "#d4fd3a"],
                    [value: 90, color: "#7cfd3a"],
                    [value: 99, color: "#55fd3a"]
                ]
		}
		standardTile("tamper", "device.tamper", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "clear", label:'', backgroundColor:"#FFFFFF", defaultState: true
			state "detected", label:'TAMPER', backgroundColor:"#e86d13"
		}

		main "water"
		details(["water", "temperatureState", "battery", "tamper"])
	}
}

def installed() {
	log.trace "Installed called settings: $settings"
	try {
		if (!state.init) {
			state.init = true
		}
        configure() // Get the updates
	} catch (e) {
		log.warn "Installed() threw $e"
	}
}

def updated() {
	log.trace "Update called settings: $settings"
	try {
		if (!state.init) {
			state.init = true
		}
        configure() // Get the updates
	} catch (e) {
		log.warn "updated() threw $e"
	}
}

def configure() {
    log.trace "Configure called"

	// Device-Watch simply pings if no device events received for 482min(checkInterval)
	sendEvent(name: "checkInterval", value: 2 * 4 * 60 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID])

    if ((device.currentValue("temperature") == null) || (device.currentValue("temperature") == "")) { // Don't reset for 0
        log.debug "Resetting temperature freeze to normal"
        def eventValue = getTemperatureScale() == "F" ? 74 : 23 // Room temp
        sendEvent(name: "temperature", value: eventValue, descriptionText: "Resetting $device.displayName to normal")
    }

    if (!device.currentValue("water")) {
        log.debug "Resetting water to dry"
        sendEvent(name: "water", value: "dry", descriptionText: "Resetting $device.displayName to dry")
    }
}

def parse(String description) {
    //log.trace description
    
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Ecolink Flood and Freeze Sensor Device Handler"]) // Save DH Name for parent app

	def result = null
	if (description.startsWith("Err 106")) {
        log.warn("Z-Wave error '$description'")
		state.sec = 0
		result = createEvent(descriptionText: description, isStateChange: true)
	} else if (description != "updated") {
		def cmd = zwave.parse(description, [0x30:2, 0x80:1, 0x84:2, 0x98:1])
		if (cmd) {
			result = zwaveEvent(cmd)
			log.debug("Parsed to $result")
		} else {
			log.warn("Couldn't zwave.parse '$description'")
		}
	}
	return result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
	def encapsulatedCommand = cmd.encapsulatedCommand([0x30:2, 0x80:1, 0x84:2])
	// log.debug "encapsulated: $encapsulatedCommand"
	if (encapsulatedCommand) {
		state.sec = 1
		zwaveEvent(encapsulatedCommand)
	}
}

def zwaveEvent(physicalgraph.zwave.commands.sensorbinaryv2.SensorBinaryReport cmd)
{
    log.trace "SensorBinaryReport: $cmd"

    def map = [:]
    switch (cmd.sensorType) {
        case 0x06:
            def eventValue = cmd.sensorValue ? "wet" : "dry"
            map = [name: "water", value: eventValue, descriptionText: "$device.displayName is $eventValue"]
        	break
            
        case 0x07:
        	def eventValue
        	if (cmd.sensorValue) { // Freeezing
	        	eventValue = getTemperatureScale() == "F" ? 32 : 0
            } else {
	        	eventValue = getTemperatureScale() == "F" ? 74 : 23 // Room temp
            }                
            map = [name: "temperature", value: eventValue, descriptionText: "$device.displayName is ${cmd.sensorValue ? "freezing" : "normal"}"]
            break
            
        default:
        	log.warn "Unknown Sensor report ${cmd.sensorType}"
            break
    }
    
    createEvent(map) // Return the map result
}
        	
def zwaveEvent(physicalgraph.zwave.commands.notificationv3.NotificationReport cmd)
{
    log.trace "NotificationReport: $cmd"
    
	def result = []
	if (cmd.notificationType == 0x05) {
		switch (cmd.event) {
            case 0x02:
	            result << createEvent(name: "water", value: "wet")
   	         break

            case 0x04:
       	     result << createEvent(name: "water", value: "dry")
    	        break
            
            default:
                log.warn "Unknown Water Notification report ${cmd.event}"
        	    break
		}
	} else if (cmd.notificationType == 0x07) {
        if (cmd.event == 0x03) {
            result << createEvent(name: "tamper", value: "detected", descriptionText: "$device.displayName covering was removed", isStateChange: true)
		} else if (cmd.event == 0x00) {
			result << createEvent(name: "tamper", value: "clear", descriptionText: "$device.displayName covering was closed", isStateChange: true)
        } else {
            log.warn "Unknown tamper notification: ${cmd.event}"
        }
	} else if (cmd.notificationType == 0x08) {
		if (cmd.event == 0x0B) {
            log.warn "Critical battery, replace immediately"
            result << createEvent(name: "battery", unit: "%", value: 1, descriptionText: "${device.displayName} has a critical battery", isStateChange: true)
		} else if (cmd.event == 0x0A) {
            log.warn "${device.displayName} has a low battery"
        } else {
            log.warn "Unknown battery notification: ${cmd.notificationType}"
        }
	} else {
        log.warn "Unknown Notification Type: ${cmd.notificationType}"
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.wakeupv2.WakeUpNotification cmd)
{
	def result = [createEvent(descriptionText: "${device.displayName} woke up", isStateChange: false)]
	if (!state.lastbat || (new Date().time) - state.lastbat > 53*60*60*1000) { // Get battery no more than every 53 hours
		result << response(zwave.batteryV1.batteryGet())
	} else {
		result << response(zwave.wakeUpV2.wakeUpNoMoreInformation())
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
	def map = [ name: "battery", unit: "%" ]
	if (cmd.batteryLevel == 0xFF) {
		map.value = 1
		map.descriptionText = "${device.displayName} has a low battery"
		map.isStateChange = true
	} else {
		map.value = cmd.batteryLevel
	}
	state.lastbat = new Date().time
	[createEvent(map), response(zwave.wakeUpV2.wakeUpNoMoreInformation())]
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	def result = []

	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	log.debug "msr: $msr"
	updateDataValue("MSR", msr)

	result << createEvent(descriptionText: "$device.displayName MSR: $msr", isStateChange: false)
	result
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
	log.warn "Unknown Z-Wave Command: $cmd"
}

private secure(cmd) {
	if (state.security) {
		zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
	} else {
		cmd.format()
	}
}

private secureSequence(commands, delay=200) {
	delayBetween(commands.collect{ secure(it) }, delay)
}

// THIS IS THE END OF THE FILE